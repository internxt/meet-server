import { createMock, DeepMocked } from '@golevelup/ts-jest';
import {
  BadRequestException,
  ConflictException,
  ForbiddenException,
  GoneException,
  NotFoundException,
} from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { Test, TestingModule } from '@nestjs/testing';
import { RoomUser } from './domain/room-user.domain';
import { Room } from './domain/room.domain';
import { RoomService } from './services/room.service';
import { CallService } from './services/call.service';
import { CallUseCase } from './call.usecase';
import { createMockRoom, mockRoomData, mockUserPayload } from './fixtures';
import { v4 } from 'uuid';
import { Time } from '../../common/time';

const autoGeneratedUUID = 'generated-uuid';

jest.mock('uuid', () => ({
  v4: jest.fn(() => autoGeneratedUUID),
}));

describe('CallUseCase', () => {
  let callUseCase: CallUseCase;
  let callService: DeepMocked<CallService>;
  let roomService: DeepMocked<RoomService>;
  let configService: DeepMocked<ConfigService>;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [CallUseCase],
    })
      .useMocker(createMock)
      .compile();

    callUseCase = module.get<CallUseCase>(CallUseCase);
    callService = module.get<DeepMocked<CallService>>(CallService);
    roomService = module.get<DeepMocked<RoomService>>(RoomService);
    configService = module.get<DeepMocked<ConfigService>>(ConfigService);

    configService.get.mockReturnValue('jitsi-app-id');
  });

  describe('validateUserHasNoActiveRoom', () => {
    it('When user has no active room, then it should not throw', async () => {
      roomService.getOpenRoomByHostId.mockResolvedValueOnce(null);

      await expect(
        callUseCase.validateUserHasNoActiveRoom(
          mockUserPayload.uuid,
          mockUserPayload.email,
        ),
      ).resolves.not.toThrow();

      expect(roomService.getOpenRoomByHostId).toHaveBeenCalledWith(
        mockUserPayload.uuid,
      );
    });

    it('When user already has an active room, then it should throw', async () => {
      roomService.getOpenRoomByHostId.mockResolvedValueOnce(
        createMock<Room>(mockRoomData),
      );

      await expect(
        callUseCase.validateUserHasNoActiveRoom(
          mockUserPayload.uuid,
          mockUserPayload.email,
        ),
      ).rejects.toThrow(ConflictException);

      expect(roomService.getOpenRoomByHostId).toHaveBeenCalledWith(
        mockUserPayload.uuid,
      );
    });
  });

  describe('createCallAndRoom', () => {
    const mockCallData = {
      room: v4(),
      paxPerCall: 10,
      appId: 'jitsi-app-id',
    };

    it('When creating call and room and user does not have an active room, then it should create call token and room successfully', async () => {
      callService.createCall.mockResolvedValueOnce(mockCallData);
      roomService.createRoom.mockResolvedValueOnce(undefined);
      jest
        .spyOn(callUseCase, 'validateUserHasNoActiveRoom')
        .mockResolvedValueOnce(null);

      const result = await callUseCase.createCallAndRoom(mockUserPayload);

      expect(callService.createCall).toHaveBeenCalledWith(mockUserPayload);
      expect(roomService.createRoom).toHaveBeenCalledWith(expect.any(Room));
      expect(result).toEqual(mockCallData);
    });
  });

  describe('joinCall', () => {
    const roomId = 'test-room-id';
    const userId = 'test-user-id';
    const userName = 'Test User';
    const userLastName = 'Last Name';
    const roomMock = createMock<Room>(mockRoomData);

    // Create a proper RoomUser mock
    const roomUserMock = new RoomUser({
      id: v4(),
      roomId,
      userId,
      name: userName,
      lastName: userLastName,
      anonymous: false,
    });

    // Create a proper anonymous RoomUser mock
    const anonymousUserMock = new RoomUser({
      id: v4(),
      roomId,
      userId: 'generated-uuid',
      name: userName,
      anonymous: true,
    });

    afterEach(() => {
      jest.useRealTimers();
    });

    it('When joining call with registered user data, then it should join successfully with current user data', async () => {
      const userData = {
        userId,
        name: userName,
        lastName: userLastName,
      };

      roomService.getRoomByRoomId.mockResolvedValueOnce(roomMock);
      roomService.getUserInRoom.mockResolvedValueOnce(null);
      roomService.countUsersInRoom.mockResolvedValueOnce(0);
      roomService.handleUserJoined.mockResolvedValueOnce({
        roomUser: roomUserMock,
        oldParticipantId: undefined,
      });
      callService.generateJitsiJWT.mockReturnValueOnce('test-jwt-token');

      const result = await callUseCase.joinCall(roomId, userData);

      expect(roomService.getRoomByRoomId).toHaveBeenCalledWith(roomId);
      expect(roomService.getUserInRoom).toHaveBeenCalledWith(
        userId,
        roomMock.id,
      );
      expect(roomService.handleUserJoined).toHaveBeenCalledWith(
        userId,
        roomMock.id,
        {
          name: userName,
          lastName: userLastName,
          anonymous: false,
        },
      );
      expect(result).toEqual({
        token: 'test-jwt-token',
        room: roomId,
        userId,
        appId: 'jitsi-app-id',
      });
    });

    it('When joining call as anonymous user without anonymousId, then it should auto-generate UUID', async () => {
      const userData = {
        anonymous: true,
        name: userName,
      };

      roomService.getRoomByRoomId.mockResolvedValueOnce(roomMock);
      roomService.getUserInRoom.mockResolvedValueOnce(null);
      roomService.countUsersInRoom.mockResolvedValueOnce(0);
      roomService.handleUserJoined.mockResolvedValueOnce({
        roomUser: anonymousUserMock,
        oldParticipantId: undefined,
      });
      callService.generateJitsiJWT.mockReturnValueOnce('test-jwt-token');

      const result = await callUseCase.joinCall(roomId, userData);

      expect(roomService.getRoomByRoomId).toHaveBeenCalledWith(roomId);
      expect(roomService.getUserInRoom).toHaveBeenCalledWith(
        autoGeneratedUUID,
        roomMock.id,
      );
      expect(roomService.handleUserJoined).toHaveBeenCalledWith(
        autoGeneratedUUID,
        roomMock.id,
        expect.objectContaining({
          name: userName,
          anonymous: true,
        }),
      );
      expect(result).toEqual({
        token: 'test-jwt-token',
        room: roomId,
        userId: anonymousUserMock.userId,
        appId: 'jitsi-app-id',
      });
    });

    it('When joining call as anonymous user with provided anonymousId, then it should use provided ID', async () => {
      const customAnonymousId = v4();
      const userData = {
        anonymous: true,
        anonymousId: customAnonymousId,
        name: userName,
      };

      const customAnonymousUserMock = new RoomUser({
        id: v4(),
        roomId,
        userId: customAnonymousId,
        name: userName,
        anonymous: true,
      });

      roomService.getRoomByRoomId.mockResolvedValueOnce(roomMock);
      roomService.getUserInRoom.mockResolvedValueOnce(null);
      roomService.countUsersInRoom.mockResolvedValueOnce(0);
      roomService.handleUserJoined.mockResolvedValueOnce({
        roomUser: customAnonymousUserMock,
        oldParticipantId: undefined,
      });
      callService.generateJitsiJWT.mockReturnValueOnce('test-jwt-token');

      const result = await callUseCase.joinCall(roomId, userData);

      expect(roomService.getRoomByRoomId).toHaveBeenCalledWith(roomId);
      expect(roomService.getUserInRoom).toHaveBeenCalledWith(
        customAnonymousId,
        roomMock.id,
      );
      expect(roomService.handleUserJoined).toHaveBeenCalledWith(
        customAnonymousId,
        roomMock.id,
        expect.objectContaining({
          name: userName,
          anonymous: true,
        }),
      );
      expect(result).toEqual({
        token: 'test-jwt-token',
        room: roomId,
        userId: customAnonymousUserMock.userId,
        appId: 'jitsi-app-id',
      });
    });

    it('When joining call as host and room is closed, then it should join successfully and open the room', async () => {
      const userData = { userId: roomMock.hostId };
      const closedRoomMock = { ...roomMock, isClosed: true };

      roomService.getRoomByRoomId.mockResolvedValueOnce(closedRoomMock);
      roomService.getUserInRoom.mockResolvedValueOnce(null);
      roomService.countUsersInRoom.mockResolvedValueOnce(0);
      roomService.handleUserJoined.mockResolvedValueOnce({
        roomUser: roomUserMock,
        oldParticipantId: undefined,
      });
      callService.generateJitsiJWT.mockReturnValueOnce('test-jwt-token');
      roomService.openRoom.mockResolvedValueOnce();

      await callUseCase.joinCall(roomId, userData);

      expect(roomService.openRoom).toHaveBeenCalledWith(roomId);
    });

    it('When room does not exist, then it should throw', async () => {
      const userData = { userId };
      roomService.getRoomByRoomId.mockResolvedValueOnce(null);

      await expect(callUseCase.joinCall(roomId, userData)).rejects.toThrow(
        NotFoundException,
      );

      expect(roomService.getRoomByRoomId).toHaveBeenCalledWith(roomId);
    });

    it('When room is expired, then it should remove the room and throw', async () => {
      const userData = { userId };
      const pastDate = Time.now('2024-01-01');
      const currentDate = Time.now('2024-01-02');
      const expiredRoomMock = {
        ...roomMock,
        removeAt: pastDate,
      };
      jest.useFakeTimers();
      jest.setSystemTime(currentDate);

      roomService.getRoomByRoomId.mockResolvedValueOnce(expiredRoomMock);
      roomService.removeRoom.mockResolvedValueOnce(undefined);

      await expect(callUseCase.joinCall(roomId, userData)).rejects.toThrow(
        GoneException,
      );
      expect(roomService.getRoomByRoomId).toHaveBeenCalledWith(roomId);
      expect(roomService.removeRoom).toHaveBeenCalledWith(expiredRoomMock.id);
    });

    it('When room has removeAt in the future, then it should allow joining', async () => {
      const userData = {
        userId,
        name: userName,
        lastName: userLastName,
      };
      const futureDate = new Date('2024-01-03');
      const currentDate = new Date('2024-01-02');
      const nonExpiredRoomMock = {
        ...roomMock,
        removeAt: futureDate,
      };
      jest.useFakeTimers();
      jest.setSystemTime(currentDate);
      roomService.getRoomByRoomId.mockResolvedValueOnce(nonExpiredRoomMock);
      roomService.getUserInRoom.mockResolvedValueOnce(null);
      roomService.countUsersInRoom.mockResolvedValueOnce(0);
      roomService.handleUserJoined.mockResolvedValueOnce({
        roomUser: roomUserMock,
        oldParticipantId: undefined,
      });
      callService.generateJitsiJWT.mockReturnValueOnce('test-jwt-token');

      const result = await callUseCase.joinCall(roomId, userData);

      expect(roomService.getRoomByRoomId).toHaveBeenCalledWith(roomId);
      expect(roomService.removeRoom).not.toHaveBeenCalled();
      expect(result).toEqual({
        token: 'test-jwt-token',
        room: roomId,
        userId,
        appId: 'jitsi-app-id',
      });
    });

    it('When non-owner tries to join closed room, then it should throw', async () => {
      const userData = { userId };
      const closedRoomMock = {
        ...roomMock,
        isClosed: true,
        hostId: 'different-host-id',
      };

      roomService.getRoomByRoomId.mockResolvedValueOnce(closedRoomMock);

      await expect(callUseCase.joinCall(roomId, userData)).rejects.toThrow(
        ForbiddenException,
      );

      expect(roomService.getRoomByRoomId).toHaveBeenCalledWith(roomId);
    });

    it('When room is full and user not already in room, then it should throw', async () => {
      const userData = { userId };
      const openRoomMock = { ...roomMock, isClosed: false, maxUsersAllowed: 2 };

      roomService.getRoomByRoomId.mockResolvedValueOnce(openRoomMock);
      roomService.getUserInRoom.mockResolvedValueOnce(null);
      roomService.countUsersInRoom.mockResolvedValueOnce(2);

      await expect(callUseCase.joinCall(roomId, userData)).rejects.toThrow(
        BadRequestException,
      );

      expect(roomService.getRoomByRoomId).toHaveBeenCalledWith(roomId);
      expect(roomService.getUserInRoom).toHaveBeenCalledWith(
        userId,
        openRoomMock.id,
      );
      expect(roomService.countUsersInRoom).toHaveBeenCalledWith(
        openRoomMock.id,
      );
    });

    it('When user already exists in room, then it should return existing user', async () => {
      const userData = { userId };
      const openRoomMock = { ...roomMock, isClosed: false };

      roomService.getRoomByRoomId.mockResolvedValueOnce(openRoomMock);
      roomService.getUserInRoom.mockResolvedValueOnce(roomUserMock);
      roomService.countUsersInRoom.mockResolvedValueOnce(1);
      roomService.handleUserJoined.mockResolvedValueOnce({
        roomUser: roomUserMock,
        oldParticipantId: undefined,
      });
      callService.generateJitsiJWT.mockReturnValueOnce('test-jwt-token');

      const result = await callUseCase.joinCall(roomId, userData);

      expect(roomService.getUserInRoom).toHaveBeenCalledWith(
        userId,
        openRoomMock.id,
      );
      expect(roomService.handleUserJoined).toHaveBeenCalledWith(
        userId,
        openRoomMock.id,
        {
          name: undefined,
          lastName: undefined,
          anonymous: false,
        },
      );
      expect(result.userId).toEqual(roomUserMock.userId);
    });
  });

  describe('processUserData', () => {
    it('When handling registered user data, then it should process correctly', async () => {
      const roomId = 'test-room-id';
      const userId = 'test-user-id';
      const name = 'Test User';
      const lastName = 'Last Name';
      const openRoomMock = createMock<Room>({
        ...mockRoomData,
        isClosed: false,
      });
      roomService.getRoomByRoomId.mockResolvedValueOnce(openRoomMock);

      const registeredRoomUser = new RoomUser({
        id: v4(),
        roomId,
        userId,
        name,
        lastName,
        anonymous: false,
      });

      roomService.getUserInRoom.mockResolvedValueOnce(null);
      roomService.countUsersInRoom.mockResolvedValueOnce(0);
      roomService.handleUserJoined.mockResolvedValueOnce({
        roomUser: registeredRoomUser,
        oldParticipantId: undefined,
      });

      await callUseCase.joinCall(roomId, {
        userId,
        name,
        lastName,
        anonymous: false,
      });
    });

    it('When handling anonymous user data, then it should process correctly', async () => {
      const roomId = 'test-room-id';
      const name = 'Anonymous User';

      const openRoomMock = createMock<Room>({
        ...mockRoomData,
        isClosed: false,
      });
      roomService.getRoomByRoomId.mockResolvedValueOnce(openRoomMock);

      const anonymousRoomUser = new RoomUser({
        id: v4(),
        roomId: openRoomMock.id,
        userId: autoGeneratedUUID,
        name,
        anonymous: true,
      });

      roomService.getUserInRoom.mockResolvedValueOnce(null);
      roomService.countUsersInRoom.mockResolvedValueOnce(0);
      roomService.handleUserJoined.mockResolvedValueOnce({
        roomUser: anonymousRoomUser,
        oldParticipantId: undefined,
      });
      callService.generateJitsiJWT.mockReturnValueOnce('test-jwt-token');

      await callUseCase.joinCall(roomId, {
        name,
        anonymous: true,
      });

      expect(roomService.handleUserJoined).toHaveBeenCalledWith(
        autoGeneratedUUID,
        openRoomMock.id,
        expect.objectContaining({
          name,
          anonymous: true,
        }),
      );
    });

    it('When user has no userId, then it should handle as anonymous with undefined userId', async () => {
      const roomId = 'test-room-id';
      const name = 'User without ID';

      const openRoomMock = createMock<Room>({
        ...mockRoomData,
        isClosed: false,
      });
      roomService.getRoomByRoomId.mockResolvedValueOnce(openRoomMock);

      const userWithoutId = new RoomUser({
        id: v4(),
        roomId: openRoomMock.id,
        userId: undefined,
        name,
        anonymous: true,
      });

      roomService.getUserInRoom.mockResolvedValueOnce(null);
      roomService.countUsersInRoom.mockResolvedValueOnce(0);
      roomService.handleUserJoined.mockResolvedValueOnce({
        roomUser: userWithoutId,
        oldParticipantId: undefined,
      });
      callService.generateJitsiJWT.mockReturnValueOnce('test-jwt-token');

      await callUseCase.joinCall(roomId, {
        name,
      });

      expect(roomService.handleUserJoined).toHaveBeenCalledWith(
        undefined,
        openRoomMock.id,
        expect.objectContaining({
          name,
          anonymous: true,
        }),
      );
    });
  });

  describe('getRoomMetadata', () => {
    const roomId = 'test-room-id';

    afterEach(() => {
      jest.useRealTimers();
    });

    it('When room exists and is not expired, then it should return room data without hostId', async () => {
      const validRoomMock = createMockRoom({
        maxUsersAllowed: 10,
        isClosed: false,
      });

      roomService.getRoomByRoomId.mockResolvedValueOnce(validRoomMock);

      const result = await callUseCase.getRoomMetadata(roomId);

      expect(roomService.getRoomByRoomId).toHaveBeenCalledWith(roomId);
      expect(result).toEqual({
        id: validRoomMock.id,
        maxUsersAllowed: validRoomMock.maxUsersAllowed,
        isClosed: validRoomMock.isClosed,
        removeAt: validRoomMock.removeAt,
        createdAt: validRoomMock.createdAt,
        updatedAt: validRoomMock.updatedAt,
      });
    });

    it('When room does not exist, then it should throw', async () => {
      roomService.getRoomByRoomId.mockResolvedValueOnce(null);

      await expect(callUseCase.getRoomMetadata(roomId)).rejects.toThrow(
        NotFoundException,
      );

      expect(roomService.getRoomByRoomId).toHaveBeenCalledWith(roomId);
    });

    it('When room is expired, then it should throw', async () => {
      const currentDate = Time.now('2025-01-02');
      const pastDate = Time.dateWithTimeAdded(-3, 'day', currentDate);
      const expiredRoomMock = createMockRoom({
        id: roomId,
        removeAt: pastDate,
      });

      jest.useFakeTimers();
      jest.setSystemTime(currentDate);

      roomService.getRoomByRoomId.mockResolvedValueOnce(expiredRoomMock);

      await expect(callUseCase.getRoomMetadata(roomId)).rejects.toThrow(
        GoneException,
      );
    });
  });

  describe('leaveCall', () => {
    const roomId = 'test-room-id';
    const hostId = 'host-user-id';
    const participantId = 'participant-user-id';
    const anonymousUserId = 'anonymous-user-id';
    let roomMock: DeepMocked<Room>;

    beforeEach(() => {
      roomMock = createMock<Room>({ ...mockRoomData, id: roomId, hostId });
      roomService.getRoomByRoomId.mockResolvedValue(roomMock);
      roomService.removeUserFromRoom.mockResolvedValue();
      roomService.closeRoom.mockResolvedValue();
      roomService.removeRoom.mockResolvedValue();
    });

    it('When a valid userId is provided, then it should handle leave call normally', async () => {
      roomService.removeUserFromRoom.mockResolvedValueOnce(undefined);
      roomService.countUsersInRoom.mockResolvedValueOnce(0);

      await callUseCase.leaveCall(roomId, participantId);

      expect(roomService.getRoomByRoomId).toHaveBeenCalledWith(roomId);
      expect(roomService.removeUserFromRoom).toHaveBeenCalledWith(
        participantId,
        roomMock,
      );
      expect(roomService.removeRoom).toHaveBeenCalledWith(roomId);
    });

    it('When room does not exist, then it should throw', async () => {
      roomService.getRoomByRoomId.mockResolvedValueOnce(null);

      await expect(
        callUseCase.leaveCall(roomId, participantId),
      ).rejects.toThrow(NotFoundException);
      expect(roomService.getRoomByRoomId).toHaveBeenCalledWith(roomId);
      expect(roomService.removeUserFromRoom).not.toHaveBeenCalled();
      expect(roomService.closeRoom).not.toHaveBeenCalled();
      expect(roomService.removeRoom).not.toHaveBeenCalled();
    });

    it('When host leaves a non-empty room, then it should remove user and close room', async () => {
      roomService.countUsersInRoom.mockResolvedValueOnce(1);

      await callUseCase.leaveCall(roomId, hostId);

      expect(roomService.getRoomByRoomId).toHaveBeenCalledWith(roomId);
      expect(roomService.removeUserFromRoom).toHaveBeenCalledWith(
        hostId,
        roomMock,
      );
      expect(roomService.countUsersInRoom).toHaveBeenCalledWith(roomId);
      expect(roomService.closeRoom).toHaveBeenCalledWith(roomId);
      expect(roomService.removeRoom).not.toHaveBeenCalled();
    });

    it('When the last user (host) leaves, then it should remove user and delete room', async () => {
      roomService.countUsersInRoom.mockResolvedValueOnce(0);

      await callUseCase.leaveCall(roomId, hostId);

      expect(roomService.getRoomByRoomId).toHaveBeenCalledWith(roomId);
      expect(roomService.removeUserFromRoom).toHaveBeenCalledWith(
        hostId,
        roomMock,
      );
      expect(roomService.countUsersInRoom).toHaveBeenCalledWith(roomId);
      expect(roomService.removeRoom).toHaveBeenCalledWith(roomId);
      expect(roomService.closeRoom).not.toHaveBeenCalled();
    });

    it('When the last user (participant) leaves, then it should remove user and delete room', async () => {
      roomService.countUsersInRoom.mockResolvedValueOnce(0);

      await callUseCase.leaveCall(roomId, participantId);

      expect(roomService.getRoomByRoomId).toHaveBeenCalledWith(roomId);
      expect(roomService.removeUserFromRoom).toHaveBeenCalledWith(
        participantId,
        roomMock,
      );
      expect(roomService.countUsersInRoom).toHaveBeenCalledWith(roomId);
      expect(roomService.removeRoom).toHaveBeenCalledWith(roomId);
      expect(roomService.closeRoom).not.toHaveBeenCalled();
    });

    it('When a participant leaves a non-empty room, then it should remove user but not close or delete room', async () => {
      roomService.countUsersInRoom.mockResolvedValueOnce(2);

      await callUseCase.leaveCall(roomId, participantId);

      expect(roomService.getRoomByRoomId).toHaveBeenCalledWith(roomId);
      expect(roomService.removeUserFromRoom).toHaveBeenCalledWith(
        participantId,
        roomMock,
      );
      expect(roomService.countUsersInRoom).toHaveBeenCalledWith(roomId);
      expect(roomService.closeRoom).not.toHaveBeenCalled();
      expect(roomService.removeRoom).not.toHaveBeenCalled();
    });

    it('When host leaves call, then it should leave successfully and close the room', async () => {
      roomService.countUsersInRoom.mockResolvedValueOnce(1);
      roomMock.hostId = hostId;

      await callUseCase.leaveCall(roomId, hostId);

      expect(roomService.getRoomByRoomId).toHaveBeenCalledWith(roomId);
      expect(roomService.removeUserFromRoom).toHaveBeenCalledWith(
        hostId,
        roomMock,
      );
      expect(roomService.countUsersInRoom).toHaveBeenCalledWith(roomId);
      expect(roomService.closeRoom).toHaveBeenCalledWith(roomId);
      expect(roomService.removeRoom).not.toHaveBeenCalled();
    });

    it('When anonymous user leaves call, then it should leave successfully', async () => {
      roomService.countUsersInRoom.mockResolvedValueOnce(1);

      await callUseCase.leaveCall(roomId, anonymousUserId);

      expect(roomService.getRoomByRoomId).toHaveBeenCalledWith(roomId);
      expect(roomService.removeUserFromRoom).toHaveBeenCalledWith(
        anonymousUserId,
        roomMock,
      );
      expect(roomService.countUsersInRoom).toHaveBeenCalledWith(roomId);
    });

    it('When error occurs during leave call operation, then it should propagate error', async () => {
      const error = new Error('Database error');
      roomService.getRoomByRoomId.mockRejectedValueOnce(error);

      await expect(
        callUseCase.leaveCall(roomId, participantId),
      ).rejects.toThrow(error);
    });

    it('When roomService throws, then it should propagate error', async () => {
      const error = new BadRequestException('Invalid user');
      roomService.getRoomByRoomId.mockResolvedValueOnce(roomMock);
      roomService.removeUserFromRoom.mockRejectedValueOnce(error);

      await expect(
        callUseCase.leaveCall(roomId, participantId),
      ).rejects.toThrow(BadRequestException);
    });
  });
});
